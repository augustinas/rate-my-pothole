# Taken from the cucumber-rails project.
# IMPORTANT: This file is generated by cucumber-sinatra - edit at your own peril
# It is recommended to regenerate this file in the future when you upgrade to a
# newer version of cucumber-sinatra. Consider adding your own code to a new file
# instead of editing this one. Cucumber automatically loads all features/**/*.rb
# files.

require 'uri'
require 'cgi'
require './features/support/paths'

module WithinHelpers

  def with_scope(locator)
    locator ? within(locator) { yield } : yield
  end

  def fill_in_form(details = {})
    details = default_details.merge(details)
    step "I fill in \"username\" with \"#{details[:name]}\""
    step "I fill in \"email\" with \"#{details[:email]}\""
    step "I fill in \"password\" with \"#{details[:password]}\""
    step "I fill in \"password_con"\
    "firmation\" with \"#{details[:password_confirmation]}\""
  end

  def default_details
    {
      name: 'citizen1',
      email: 'angry@citizen.com',
      password: 'ra88it',
      password_confirmation: 'ra88it'
    }
  end

end
World(WithinHelpers)

Given(/^I sign up$/) do
  step 'I am on the homepage'
  step 'I press "Sign up"'
  fill_in_form
  step 'I press "Register"'
end

Given(/^I sign up with the same email$/) do
  step 'I am on the homepage'
  step 'I press "Sign up"'
  fill_in_form(name: 'citizen2')
  step 'I press "Register"'
end

Given(/^I sign up as "([^"]*)"$/) do |name|
  step 'I am on the homepage'
  step 'I press "Sign up"'
  fill_in_form(name: name, email: "#{name}@emailsRus.com")
  step 'I press "Register"'
end

When(/^I fill in form with mismatching passwords$/) do
  fill_in_form(password_confirmation: 'b')
end

When(/^I fill in form with short password$/) do
  fill_in_form(password_confirmation: 'rat', password: 'rat')
end

Given(/^I post a pothole$/) do
  step 'I am on the homepage'
  step 'I press "Report Pothole"'
  step 'I fill in "street_name" with "Leeds Rd"'
  step 'I fill in "town_name" with "Liversedge"'
  step 'I press "Report"'
  step 'I should see "Pothole reported on Leeds Rd"'
  step 'I see "Leeds Rd" within ".pothole-list__item"'
end

Given(
  /^I step in my time machine and travel (\d+) days into the distant future$/
) do |days|
  Timecop.freeze(Date.today + days.to_i)
end

Then(/^"([^"]*)" should be before "([^"]*)"$/) do |arg1, arg2|
  arg1.should appear_before(arg2)
end

Given(/^the database is populated with potholes$/) do
  london = Town.first_or_create(name: "London")
  leeds = Town.first_or_create(name: "Leeds")
  liversedge = Town.first_or_create(name: "Liversedge")
  bournemouth = Town.first_or_create(name: "Bournemouth")
  Pothole.create(location: "street 1", town: london)
  Pothole.create(location: "main ave", town: leeds)
  Pothole.create(location: "Leeds Rd", town: liversedge)
  Pothole.create(location: "Drive-by park", town: bournemouth)
end

Given(/^I press "([^"]*)" on pothole "([^"]*)"$/) do |arg1, arg2|
  find(".pothole-list__item__#{arg1}-button--#{arg2}").click
end

When(/^I wait (\d+) seconds$/) do |seconds|
  sleep seconds.to_i
end

Given(/^I post a pothole on "([^"]*)"$/) do |street|
  step 'I am on the homepage'
  step 'I press "Report Pothole"'
  step "I fill in \"street_name\" with \"#{street}\""
  step 'I fill in "town_name" with "Liversedge"'
  step 'I press "Report"'
end

When(/^I send an http request$/) do
  uri = URI("https://api.github.com/repos/thoughtbot/factory_girl/contributors")
  @response = Net::HTTP.get(uri)
end

Then(/^I expect to get a response$/) do
  expect(@response).to be_an_instance_of String
end

Given(/^(?:|I )am on (.+)$/) do |page_name|
  visit path_to(page_name)
end

When(/^(?:|I )go to (.+)$/) do |page_name|
  visit path_to(page_name)
end

When(/^(?:|I )press "([^\"]*)"(?: within "([^\"]*)")?$/) do |button, selector|
  with_scope(selector) do
    click_button(button)
  end
end

When(/^(?:|I )follow "([^\"]*)"(?: within "([^\"]*)")?$/) do |link, selector|
  with_scope(selector) do
    click_link(link)
  end
end

When(
  /^(?:|I )fill in "([^\"]*)" with "([^\"]*)"(?: within "([^\"]*)")?$/
) do |field, value, selector|
  with_scope(selector) do
    fill_in(field, with: value)
  end
end

When(
  /^(?:|I )fill in "([^\"]*)" for "([^\"]*)"(?: within "([^\"]*)")?$/
) do |value, field, selector|
  with_scope(selector) do
    fill_in(field, with: value)
  end
end

# Use this to fill in an entire form with data from a table. Example:
#
#   When I fill in the following:
#     | Account Number | 5002       |
#     | Expiry date    | 2009-11-01 |
#     | Note           | Nice guy   |
#     | Wants Email?   |            |
#
# TODO: Add support for checkbox, select og option
# based on naming conventions.
#
When(
  /^(?:|I )fill in the following(?: within "([^\"]*)")?:$/
) do |selector, fields|
  with_scope(selector) do
    fields.rows_hash.each do |name, value|
      When %(I fill in "#{name}" with "#{value}")
    end
  end
end

When(
  /^(?:|I )select "([^\"]*)" from "([^\"]*)"(?: within "([^\"]*)")?$/
) do |value, field, selector|
  with_scope(selector) do
    select(value, from: field)
  end
end

When(/^(?:|I )check "([^\"]*)"(?: within "([^\"]*)")?$/) do |field, selector|
  with_scope(selector) do
    check(field)
  end
end

When(/^(?:|I )uncheck "([^\"]*)"(?: within "([^\"]*)")?$/) do |field, selector|
  with_scope(selector) do
    uncheck(field)
  end
end

When(/^(?:|I )choose "([^\"]*)"(?: within "([^\"]*)")?$/) do |field, selector|
  with_scope(selector) do
    choose(field)
  end
end

Then(/^(?:|I )should see JSON:$/) do |expected_json|
  require 'json'
  expected = JSON.pretty_generate(JSON.parse(expected_json))
  actual   = JSON.pretty_generate(JSON.parse(response.body))
  expected.should == actual
end

Then(
  /^(?:|I )should see "([^\"]*)"(?: within "([^\"]*)")?$/
) do |text, selector|
  with_scope(selector) do
    if page.respond_to? :should
      page.should have_content(text)
    else
      assert page.has_content?(text)
    end
  end
end

Then(/^I see "([^"]*)" within "([^"]*)"$/) do |text, selector|
  expect(find(selector)).to have_content(text)
end

Then(
  %r{/^(?:|I ) should see \/([^\/]*)\/(?: within "([^\"]*)")?$/}
) do |regexp, selector|
  regexp = Regexp.new(regexp)
  with_scope(selector) do
    if page.respond_to? :should
      page.should have_xpath('//*', text: regexp)
    else
      assert page.has_xpath?('//*', text: regexp)
    end
  end
end

Then(
  /^(?:|I )should not see "([^\"]*)"(?: within "([^\"]*)")?$/
) do |text, selector|
  with_scope(selector) do
    if page.respond_to? :should
      page.should have_no_content(text)
    else
      assert page.has_no_content?(text)
    end
  end
end

Then(
  %r{/^(?:|I )should not see \/([^\/]*)\/(?: within "([^\"]*)")?$/}
) do |regexp, selector|
  regexp = Regexp.new(regexp)
  with_scope(selector) do
    if page.respond_to? :should
      page.should have_no_xpath('//*', text: regexp)
    else
      assert page.has_no_xpath?('//*', text: regexp)
    end
  end
end

Then(
  /^the "([^\"]*)" checkbox(?: within "([^\"]*)")? should be checked$/
) do |label, selector|
  with_scope(selector) do
    field_checked = find_field(label)['checked']
    if field_checked.respond_to? :should
      field_checked.should == 'checked'
    else
      assert_equal 'checked', field_checked
    end
  end
end

Then(
  /^the "([^\"]*)" checkbox(?: within "([^\"]*)")? should not be checked$/
) do |label, selector|
  with_scope(selector) do
    field_checked = find_field(label)['checked']
    if field_checked.respond_to? :should_not
      field_checked.should_not == 'checked'
    else
      assert_not_equal 'checked', field_checked
    end
  end
end

Then(/^(?:|I )should be on (.+)$/) do |page_name|
  current_path = URI.parse(current_url).path
  if current_path.respond_to? :should
    current_path.should == path_to(page_name)
  else
    assert_equal path_to(page_name), current_path
  end
end

Then(
  /^(?:|I )should have the following query string:$/
) do |expected_pairs|
  query = URI.parse(current_url).query
  actual_params = query ? CGI.parse(query) : {}
  expected_params = {}
  expected_pairs.rows_hash.each_pair do |k, v|
    expected_params[k] = v.split(',')
  end

  if actual_params.respond_to? :should
    actual_params.should == expected_params
  else
    assert_equal expected_params, actual_params
  end
end
